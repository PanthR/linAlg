<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="doc.css" type="text/css" media="screen" title="no title" charset="utf-8">
    <title>Vector</title>
  </head>
  <body>
    <div id="header">
    <h1>Documentation for module <code>Vector</code>
      
      </h1>
    </div>
    <div id="sidebar">
      <div>
        <h3>Module Index</h3>
      <ul>
        
        <a href="LinAlg.html"><li><code>LinAlg</code></li></a>
        
        <a href="Matrix.html"><li><code>Matrix</code></li></a>
        
        <a href="Vector.html"><li><code>Vector</code></li></a>
        
      </ul>
      </div>
      <div>
        <h3>Contents</h3>
      <ul>
        
        <a href="#Vector"><li><code>Vector</code></li></a>
        
        <a href="#Vector.ConstV"><li><code>Vector.ConstV</code></li></a>
        
        <a href="#Vector.DenseV"><li><code>Vector.DenseV</code></li></a>
        
        <a href="#Vector.SparseV"><li><code>Vector.SparseV</code></li></a>
        
        <a href="#Vector.TabularV"><li><code>Vector.TabularV</code></li></a>
        
        <a href="#Vector.const"><li><code>Vector.const</code></li></a>
        
        <a href="#Vector.ones"><li><code>Vector.ones</code></li></a>
        
        <a href="#Vector.seq"><li><code>Vector.seq</code></li></a>
        
        <a href="#Vector%25compute"><li><code>Vector#compute</code></li></a>
        
        <a href="#Vector%25cumMax"><li><code>Vector#cumMax</code></li></a>
        
        <a href="#Vector%25cumMin"><li><code>Vector#cumMin</code></li></a>
        
        <a href="#Vector%25cumProd"><li><code>Vector#cumProd</code></li></a>
        
        <a href="#Vector%25cumSum"><li><code>Vector#cumSum</code></li></a>
        
        <a href="#Vector%25cumulative"><li><code>Vector#cumulative</code></li></a>
        
        <a href="#Vector%25diff"><li><code>Vector#diff</code></li></a>
        
        <a href="#Vector%25dot"><li><code>Vector#dot</code></li></a>
        
        <a href="#Vector%25each"><li><code>Vector#each</code></li></a>
        
        <a href="#Vector%25eachPair"><li><code>Vector#eachPair</code></li></a>
        
        <a href="#Vector%25foldl"><li><code>Vector#foldl</code></li></a>
        
        <a href="#Vector%25force"><li><code>Vector#force</code></li></a>
        
        <a href="#Vector%25get"><li><code>Vector#get</code></li></a>
        
        <a href="#Vector%25map"><li><code>Vector#map</code></li></a>
        
        <a href="#Vector%25mapPair"><li><code>Vector#mapPair</code></li></a>
        
        <a href="#Vector%25norm"><li><code>Vector#norm</code></li></a>
        
        <a href="#Vector%25pAdd"><li><code>Vector#pAdd</code></li></a>
        
        <a href="#Vector%25pDiv"><li><code>Vector#pDiv</code></li></a>
        
        <a href="#Vector%25pMult"><li><code>Vector#pMult</code></li></a>
        
        <a href="#Vector%25pPow"><li><code>Vector#pPow</code></li></a>
        
        <a href="#Vector%25pSub"><li><code>Vector#pSub</code></li></a>
        
        <a href="#Vector%25reduce"><li><code>Vector#reduce</code></li></a>
        
        <a href="#Vector%25reducePair"><li><code>Vector#reducePair</code></li></a>
        
        <a href="#Vector%25sMult"><li><code>Vector#sMult</code></li></a>
        
        <a href="#Vector%25set"><li><code>Vector#set</code></li></a>
        
        <a href="#Vector%25toArray"><li><code>Vector#toArray</code></li></a>
        
      </ul>
      </div>
    </div>
    <div id="main">
      <div class="moduleInfo">
        <h2>Module <code>Vector</code></h2>
        <p>Author(s): <a class="author" href="mailto:skiadas@hanover.edu">Haris Skiadas</a>, <a class="author" href="mailto:wahl@hanover.edu">Barb Wahl</a><p>
        <p>Javascript implementation of Linear Algebra Vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector"><code>Vector(arr, len)</code></h4>
        <p><a href="#Vector"><code>Vector</code></a> objects are Javascript representations of real-valued vectors.
They are constructed in one of three ways depending on the type of the first parameter <code>arr</code>:</p>
<ol>
<li>Based on an array of values. In this case, the resulting vector length <code>len</code> is optional.</li>
<li>Based on a key-value object representing the non-zero indices and their values (sparse vectors)</li>
<li>Based on a function <code>f(n)</code> describing how the i-th index is meant to be computed.</li>
</ol>
<p><a href="#Vector"><code>Vector</code></a> objects are 1-indexed. By default, they are immutable structures, they cannot be edited
once created. See <code>Vector.MutableV</code> for a description of mutable vectors.</p>
<p>Every vector has a fixed <code>length</code>, accessed as a property.
Vectors of length 0 are allowed, though there is not much one can do with them.</p>
<pre class="prettyprint source"><code>// A length-4 vector
var v1 = new Vector([3, 5, 1, 2]);
// A length-10 sparse vector
var v2 = new Vector({ 4: 10, 2: 12 }, 10);
// A length-3 vector with values exp(1), exp(2), exp(3)
var v3 = new Vector(Math.exp, 3);
v3.length === 3  // true</code></pre>
      </div>
      
      <div>
        <h4 id="Vector.DenseV"><code>Vector.DenseV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing &quot;dense&quot; vectors.
Dense vectors are internally stored simply as Javascript Arrays
Users should not need to access this directly.</p>
      </div>
      
      <div>
        <h4 id="Vector.SparseV"><code>Vector.SparseV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing &quot;sparse&quot; vectors.
Sparce vectors are stored as objects, whose keys represent the indices
that have non-zero values.
Users should not need to access this directly.</p>
      </div>
      
      <div>
        <h4 id="Vector.TabularV"><code>Vector.TabularV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing vectors whose values are specified via
a function <code>f(i)</code> of the index.
The values of the vector are computed lazily, only when they are accessed.
Users should not need to access this directly.</p>
      </div>
      
      <div>
        <h4 id="Vector.ConstV"><code>Vector.ConstV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing efficiently vectors all of whose
values are meant to be the same number.
Users should not need to access this directly.
Use <a href="#Vector.const"><code>Vector.const</code></a> or <a href="#Vector.ones"><code>Vector.ones</code></a> instead.</p>
      </div>
      
      <div>
        <h4 id="Vector.seq"><code>Vector.seq(a, b, step)</code></h4>
        <p>Create a vector that follows a linear progression starting from <code>a</code> increasing
by <code>step</code> amount, and ending the moment <code>b</code> is exceeded.</p>
<p>If <code>step</code> is omitted, it defaults to 1 or -1 depending on the relation between
<code>a</code> and <code>b</code>. If <code>b</code> is also omitted, then the vector generated is <code>1,2,...,a</code>.</p>
<pre class="prettyprint source"><code>Vector.seq(1, 6, 2)  // Produces [1, 3, 5]
Vector.seq(5, 1)     // Produces [5, 4, 3, 2, 1]
Vector.seq(3)        // Produces [1, 2, 3]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector.const"><code>Vector.const(val, len)</code></h4>
        <p>Generates a constant vector of length <code>len</code>, with all entries having value <code>val</code>.</p>
      </div>
      
      <div>
        <h4 id="Vector.ones"><code>Vector.ones(len)</code></h4>
        <p>Generates a constant vector of length <code>len</code>, with all entries having value 1.</p>
<pre class="prettyprint source"><code>// Sums all elements of v1
Vector.ones(v1.length).dot(v1)</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25get"><code>Vector#get(i)</code></h4>
        <p>Get the entry at index <code>i</code> of the vector. Vector indexing begins from 1.
Users should always go through this method when accessing values of the vector.</p>
<pre class="prettyprint source"><code>v1.get(1) === 3;
v1.get(2) === 5;
// Out of range defaults to 0
v1.get(0) === 0;
v1.get(5) === 0;</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25set"><code>Vector#set(i, v)</code></h4>
        <p>Set the entry at index <code>i</code> of the vector. Users should avoid calling this method.
TODO: This will be moved to the MutableV subclass</p>
      </div>
      
      <div>
        <h4 id="Vector%25force"><code>Vector#force()</code></h4>
        <p>Force a vector to be evaluated. This resolves any deferred calculations
needed for the computation of the vector's elements.</p>
      </div>
      
      <div>
        <h4 id="Vector%25compute"><code>Vector#compute(i)</code></h4>
        <p>Compute the entry at index <code>i</code> of the vector. This method is used internally
by <a href="#Vector%25get"><code>Vector.prototype.get</code></a> to obtain the correct value in cases where the vector
values are stored <em>lazily</em>. Users should not call it directly.
Use <a href="#Vector%25get"><code>Vector.prototype.get</code></a> instead.</p>
      </div>
      
      <div>
        <h4 id="Vector%25each"><code>Vector#each(f, skipZeros)</code></h4>
        <p>Execute the function <code>f</code> for each entry from <code>this</code>,
starting with the entry with index 1. <code>f</code> will be called as <code>f(value, index)</code>.
If <code>skipZeros</code> is <code>true</code>, then the system <em>may</em> skip the execution
of <code>f</code> for zero-entries.</p>
<pre class="prettyprint source"><code>// Prints: 3 1, 5 2, 1 3, 2 4
v.each(console.log);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25eachPair"><code>Vector#eachPair(v2, f, skipZeros)</code></h4>
        <p>Execute the function <code>f</code> for each pair of corresponding entries from the
vectors <code>v1</code> and <code>v2</code>, starting with the entries with index 1.
<code>f</code> will be called as <code>f(value1, value2, index)</code>, where <code>value1</code>, <code>value2</code>
are the entries of the vectors <code>v1</code>, <code>v2</code> at index <code>i</code>.
If <code>skipZeros</code> is <code>true</code>, then the system <em>may</em> skip the execution of <code>f</code> when
one of the values is 0.</p>
<pre class="prettyprint source"><code>// Prints 3 3 1, 5 5 2, 1 1 3, 2 2 4
v1.eachPair(v1, console.log);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25reduce"><code>Vector#reduce(f, initial, skipZeros)</code></h4>
        <p>Similar to <code>Array.prototype.reduce</code>. Given a function <code>f(acc, val, i)</code> and an
<code>initial</code> value, it successively calls the function on the vector's entries,
storing each result in the variable <code>acc</code>, then feeding that value back.
If <code>skipZeros</code> is <code>true</code>, this operation <em>may</em> skip any zero entries.
<code>initial</code> and <code>acc</code> do not have to be numbers, but they do need to have the
same type, and <code>f</code> should return that same type.</p>
<pre class="prettyprint source"><code>function add(acc, val) { return acc + val; };
// Equivalent to ((((4 + 3) + 5) + 1) + 2)
v1.reduce(add, 4);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25reducePair"><code>Vector#reducePair(v2, f, initial, skipZeros)</code></h4>
        <p>Similar to <a href="#Vector%25reduce"><code>Vector.prototype.reduce</code></a> but acts on a pair of vectors <code>v1</code>, <code>v2</code>.
The signature of the function <code>f</code> would be <code>f(acc, val1, val2, i)</code> where <code>acc</code>
is the accumulated value, <code>i</code> is the index, and <code>val1</code>, <code>val2</code> are the <code>i</code>-indexed
values from <code>v1</code>, <code>v2</code>. If <code>skipZeros</code> is <code>true</code>, the implementation <em>may</em> avoid
calling <code>f</code> for an index <code>i</code> if one of the values there is 0.</p>
<p>The vectors <code>v1</code>, <code>v2</code> need to have the same length.</p>
<pre class="prettyprint source"><code>function f(acc, val1, val2) = { return acc + val1 * val2; };
// Computes the dot product of v1, v2.
v1.reducePair(v2, f, 0)</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25foldl"><code>Vector#foldl</code></h4>
        <p>Alias for <a href="#Vector%25reduce"><code>Vector.prototype.reduce</code></a>.</p>
      </div>
      
      <div>
        <h4 id="Vector%25map"><code>Vector#map(f, skipZeros)</code></h4>
        <p>Create a new vector by applying the function <code>f</code> to all elements of <code>this</code>.
The function <code>f</code> has the signature <code>f(val, i)</code>.
If <code>skipZeros</code> is <code>true</code>, the operation may assume that <code>f(0, i)=0</code> and
may choose to skip those computations.</p>
<p><a href="#Vector%25map"><code>Vector#map</code></a> only returns a &quot;promise&quot; to compute the resulting vector.
The implementation may choose to not actually compute values <code>f</code> until
they are actually needed. Users should not rely on side-effects of <code>f</code>.</p>
<pre class="prettyprint source"><code>// Results in [4, 7, 4, 6];
v1.map(function(val, i) { return val + i; });</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25mapPair"><code>Vector#mapPair(v2, f, skipZeros)</code></h4>
        <p>Like <code>Vector.map</code>, but the function <code>f</code> acts on two vectors, with signature
<code>f(val1, val2, i)</code>. If <code>skipZeros</code> is <code>true</code>, the implementation may
assume that <code>f</code> will return 0 as long as one of the values is 0.</p>
      </div>
      
      <div>
        <h4 id="Vector%25norm"><code>Vector#norm(p)</code></h4>
        <p>Compute the p-norm of the vector. <code>p</code> should be a positive
number or <code>Infinity</code>. Defaults to the 2-norm.</p>
<pre class="prettyprint source"><code>v.norm(1)        // 1-norm (sum of absolute values)
v.norm()           // 2 norm (usual formula)
v.norm(Infinity) // Infinity (max) norm</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25dot"><code>Vector#dot(v)</code></h4>
        <p>Compute the dot product of <code>this</code> with <code>v</code>.</p>
<pre class="prettyprint source"><code>// Returns 3 * 3 + 5 * 5 + 1 * 1 + 2 * 2
v1.dot(v1);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25toArray"><code>Vector#toArray()</code></h4>
        <p>Return a Javascript array of the vector's values. Returns a new
Array object every time.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pAdd"><code>Vector#pAdd(v)</code></h4>
        <p>Pointwise add two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pSub"><code>Vector#pSub(v)</code></h4>
        <p>Pointwise subtract two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25sMult"><code>Vector#sMult(a)</code></h4>
        <p>Multiply the vector <code>v</code> by the constant <code>a</code>.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pMult"><code>Vector#pMult(v)</code></h4>
        <p>Pointwise multiply two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pDiv"><code>Vector#pDiv(v)</code></h4>
        <p>Pointwise divide two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pPow"><code>Vector#pPow(n)</code></h4>
        <p>Raise each entry in <code>v</code> to the <code>n</code>-th power. Return the resulting vector.</p>
      </div>
      
      <div>
        <h4 id="Vector%25diff"><code>Vector#diff()</code></h4>
        <p>Compute consecutive differences of the values in the vector.</p>
<pre class="prettyprint source"><code>// Both produce: [2, -4, 1]
Vector.diff(v1);
v1.diff();
v1.diff().length === v1.length - 1 // true</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumulative"><code>Vector#cumulative(f, initial)</code></h4>
        <p>Create a new vector by accumulating one by one the results
<code>f(acc, val, i)</code> as <code>val</code> ranges over the values of the vector,
starting with the value <code>initial</code>. This is effectively a version of
<code>Vector.reduce</code> where each intermediate step is stored.</p>
<pre class="prettyprint source"><code>function f(acc, val) { return acc + val * val; }
v1.cumulative(f, 2);  // Produces [11, 36, 37, 41]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumSum"><code>Vector#cumSum()</code></h4>
        <p>Create a new vector from the partial sums in the vector.</p>
<pre class="prettyprint source"><code>// Both produce [3, 8, 9, 11]
Vector.prototype.cumSum(v1);
v1.cumSum();</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumProd"><code>Vector#cumProd()</code></h4>
        <p>Create a new vector from the partial products in the vector.</p>
<pre class="prettyprint source"><code>v1.cumProd(); // Produces [3, 15, 15, 30]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumMin"><code>Vector#cumMin()</code></h4>
        <p>Create a new vector from the partial minimums in the vector.</p>
<pre class="prettyprint source"><code>v1.cumMin(); // Produces [3, 5, 1, 1]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumMax"><code>Vector#cumMax()</code></h4>
        <p>Create a new vector from the partial maximums in the vector.</p>
<pre class="prettyprint source"><code>v1.cumMax(); // Produces [3, 5, 5, 5]</code></pre>
      </div>
      
      <div>
        
        
      </div>
      
    </div>
  </body>
</html>