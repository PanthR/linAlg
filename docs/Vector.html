<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="doc.css" type="text/css" media="screen" title="no title" charset="utf-8">
    <title>Vector</title>
  </head>
  <body>
    <div id="header">
    <h1>Documentation for module <code>Vector</code>
      
      </h1>
    </div>
    <div id="sidebar">
      <div>
        <h3>Module Index</h3>
      <ul>
        
        <a href="LinAlg.html"><li><code>LinAlg</code></li></a>
        
        <a href="Matrix.html"><li><code>Matrix</code></li></a>
        
        <a href="utils.html"><li><code>utils</code></li></a>
        
        <a href="Vector.html"><li><code>Vector</code></li></a>
        
      </ul>
      </div>
      <div>
        <h3>Contents</h3>
      <ul>
        
        <a href="#Vector"><li><code>Vector</code></li></a>
        
        <a href="#Vector.ConstV"><li><code>Vector.ConstV</code></li></a>
        
        <a href="#Vector.DenseV"><li><code>Vector.DenseV</code></li></a>
        
        <a href="#Vector.SparseV"><li><code>Vector.SparseV</code></li></a>
        
        <a href="#Vector.TabularV"><li><code>Vector.TabularV</code></li></a>
        
        <a href="#Vector.ViewV"><li><code>Vector.ViewV</code></li></a>
        
        <a href="#Vector.const"><li><code>Vector.const</code></li></a>
        
        <a href="#Vector.fill"><li><code>Vector.fill</code></li></a>
        
        <a href="#Vector.ones"><li><code>Vector.ones</code></li></a>
        
        <a href="#Vector.seq"><li><code>Vector.seq</code></li></a>
        
        <a href="#Vector.tolerance"><li><code>Vector.tolerance</code></li></a>
        
        <a href="#Vector%25_get"><li><code>Vector#_get</code></li></a>
        
        <a href="#Vector%25_set"><li><code>Vector#_set</code></li></a>
        
        <a href="#Vector%25change"><li><code>Vector#change</code></li></a>
        
        <a href="#Vector%25clone"><li><code>Vector#clone</code></li></a>
        
        <a href="#Vector%25compute"><li><code>Vector#compute</code></li></a>
        
        <a href="#Vector%25cumMax"><li><code>Vector#cumMax</code></li></a>
        
        <a href="#Vector%25cumMin"><li><code>Vector#cumMin</code></li></a>
        
        <a href="#Vector%25cumProd"><li><code>Vector#cumProd</code></li></a>
        
        <a href="#Vector%25cumSum"><li><code>Vector#cumSum</code></li></a>
        
        <a href="#Vector%25cumulative"><li><code>Vector#cumulative</code></li></a>
        
        <a href="#Vector%25diff"><li><code>Vector#diff</code></li></a>
        
        <a href="#Vector%25dot"><li><code>Vector#dot</code></li></a>
        
        <a href="#Vector%25each"><li><code>Vector#each</code></li></a>
        
        <a href="#Vector%25eachPair"><li><code>Vector#eachPair</code></li></a>
        
        <a href="#Vector%25equals"><li><code>Vector#equals</code></li></a>
        
        <a href="#Vector%25fill"><li><code>Vector#fill</code></li></a>
        
        <a href="#Vector%25foldl"><li><code>Vector#foldl</code></li></a>
        
        <a href="#Vector%25forEach"><li><code>Vector#forEach</code></li></a>
        
        <a href="#Vector%25force"><li><code>Vector#force</code></li></a>
        
        <a href="#Vector%25get"><li><code>Vector#get</code></li></a>
        
        <a href="#Vector%25isSparse"><li><code>Vector#isSparse</code></li></a>
        
        <a href="#Vector%25map"><li><code>Vector#map</code></li></a>
        
        <a href="#Vector%25mapPair"><li><code>Vector#mapPair</code></li></a>
        
        <a href="#Vector%25mutable"><li><code>Vector#mutable</code></li></a>
        
        <a href="#Vector%25norm"><li><code>Vector#norm</code></li></a>
        
        <a href="#Vector%25pAdd"><li><code>Vector#pAdd</code></li></a>
        
        <a href="#Vector%25pDiv"><li><code>Vector#pDiv</code></li></a>
        
        <a href="#Vector%25pMult"><li><code>Vector#pMult</code></li></a>
        
        <a href="#Vector%25pPow"><li><code>Vector#pPow</code></li></a>
        
        <a href="#Vector%25pSub"><li><code>Vector#pSub</code></li></a>
        
        <a href="#Vector%25reduce"><li><code>Vector#reduce</code></li></a>
        
        <a href="#Vector%25reducePair"><li><code>Vector#reducePair</code></li></a>
        
        <a href="#Vector%25sMult"><li><code>Vector#sMult</code></li></a>
        
        <a href="#Vector%25sameLength"><li><code>Vector#sameLength</code></li></a>
        
        <a href="#Vector%25set"><li><code>Vector#set</code></li></a>
        
        <a href="#Vector%25toArray"><li><code>Vector#toArray</code></li></a>
        
        <a href="#Vector%25view"><li><code>Vector#view</code></li></a>
        
      </ul>
      </div>
    </div>
    <div id="main">
      <div class="moduleInfo">
        <h2>Module <code>Vector</code></h2>
        <p>Author(s): <a class="author" href="mailto:skiadas@hanover.edu">Haris Skiadas</a>, <a class="author" href="mailto:wahl@hanover.edu">Barb Wahl</a><p>
        <p>Javascript implementation of Linear Algebra Vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector"><code>Vector(arr, len)</code></h4>
        <p><a href="#Vector"><code>Vector</code></a> objects are Javascript representations of real-valued vectors.
They are constructed in one of three ways depending on the type of the first parameter <code>arr</code>:</p>
<ol>
<li>Based on an array of values. In this case, the resulting vector length <code>len</code> is optional.</li>
<li>Based on a key-value object representing the non-zero indices and their values (sparse vectors)</li>
<li>Based on a function <code>f(n)</code> describing how the i-th index is meant to be computed.</li>
</ol>
<p>When <code>arr</code> is a <a href="#Vector"><code>Vector</code></a>, it is simply returned unchanged.</p>
<p><a href="#Vector"><code>Vector</code></a> objects are 1-indexed. By default, they are immutable structures, they cannot be edited
once created. See <code>Vector.MutableV</code> for a description of mutable vectors.</p>
<p>Every vector has a fixed <code>length</code>, accessed as a property.
Vectors of length 0 are allowed, though there is not much one can do with them.</p>
<pre class="prettyprint source"><code>// A length-4 vector
var v1 = new Vector([3, 5, 1, 2]);
// A length-10 sparse vector
var v2 = new Vector({ 4: 10, 2: 12 }, 10);
// A length-3 vector with values exp(1), exp(2), exp(3)
var v3 = new Vector(Math.exp, 3);
v3.length === 3  // true</code></pre>
      </div>
      
      <div>
        <h4 id="Vector.tolerance"><code>Vector.tolerance</code></h4>
        <p>The tolerance used in equality tests. You may set a different value.</p>
      </div>
      
      <div>
        <h4 id="Vector.DenseV"><code>Vector.DenseV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing &quot;dense&quot; vectors.
Dense vectors are internally stored simply as Javascript Arrays.
Users should not need to access this directly.</p>
      </div>
      
      <div>
        <h4 id="Vector.SparseV"><code>Vector.SparseV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing &quot;sparse&quot; vectors.
Sparce vectors are stored as objects, whose keys represent the indices
that have non-zero values.
Users should not need to access this directly.</p>
      </div>
      
      <div>
        <h4 id="Vector.TabularV"><code>Vector.TabularV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing vectors whose values are specified via
a function <code>f(i)</code> of the index.
The values of the vector are computed lazily, only when they are accessed.
Users should not need to access this directly.</p>
      </div>
      
      <div>
        <h4 id="Vector.ConstV"><code>Vector.ConstV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing efficiently vectors all of whose
values are meant to be the same number.
Users should not need to access this directly.
Use <a href="#Vector.const"><code>Vector.const</code></a> or <a href="#Vector.ones"><code>Vector.ones</code></a> instead.</p>
      </div>
      
      <div>
        <h4 id="Vector.ViewV"><code>Vector.ViewV</code></h4>
        <p>Subclass of <a href="#Vector"><code>Vector</code></a> representing vectors that provide a &quot;view&quot; into
another object, e.g. the row or column of a <a href="#Matrix"><code>Matrix</code></a>. Changes to a view
vector cause changes to the corresponding &quot;viewed&quot; object and vice versa.</p>
      </div>
      
      <div>
        <h4 id="Vector.seq"><code>Vector.seq(a, b, step)</code></h4>
        <p>Create a vector that follows a linear progression starting from <code>a</code> increasing
by <code>step</code> amount, and ending the moment <code>b</code> is exceeded.</p>
<p>If <code>step</code> is omitted, it defaults to 1 or -1 depending on the relation between
<code>a</code> and <code>b</code>. If <code>b</code> is also omitted, then the vector generated is <code>1,2,...,a</code>.</p>
<pre class="prettyprint source"><code>Vector.seq(1, 6, 2)  // Produces [1, 3, 5]
Vector.seq(5, 1)     // Produces [5, 4, 3, 2, 1]
Vector.seq(3)        // Produces [1, 2, 3]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector.fill"><code>Vector.fill(val, len)</code></h4>
        <p>Generate a vector of length <code>len</code>, with all entries having value <code>val</code>.
This vector can become mutable. Use this to set starting values for a vector.</p>
      </div>
      
      <div>
        <h4 id="Vector.const"><code>Vector.const(val, len)</code></h4>
        <p>Generate a constant vector of length <code>len</code>, with all entries having value <code>val</code>.
Constant vectors are immutable.</p>
      </div>
      
      <div>
        <h4 id="Vector.ones"><code>Vector.ones(len)</code></h4>
        <p>Generate a constant vector of length <code>len</code>, with all entries having value 1.
Constant vectors are immutable.</p>
<pre class="prettyprint source"><code>// Sums all elements of v1
Vector.ones(v1.length).dot(v1)</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25get"><code>Vector#get(i)</code></h4>
        <p>Generic accessor method to obtain the values in the vector. The argument <code>i</code> can take a
number of different forms:</p>
<ol>
<li>With no argument present, an array of all vector values is returned.</li>
<li>If called with an integer <code>i</code>, the <code>i</code>-th entry from the vector is returned
(indexing starts at 1).</li>
<li>If called with an array of integers, an array of the correspondigly indexed entries is returned.</li>
</ol>
<p>Users should always go through this method, or <a href="#Vector%25_get"><code>Vector.prototype._get</code></a>, when accessing
values of the vector unless they really know what they're doing.
You may use <a href="#Vector%25_get"><code>Vector.prototype._get</code></a> for slightly more efficient access, if you will always
be accessing values via an integer.</p>
<pre class="prettyprint source"><code>v1.get() === [3, 5, 1, 2];
v1.get([2, 3]) === [5, 1];
v1.get(1) === 3;
v1.get(2) === 5;
// Out of range defaults to 0
v1.get(0) === 0;
v1.get(5) === 0;</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25_get"><code>Vector#_get(i)</code></h4>
        <p>Same as <a href="#Vector%25get"><code>Vector.prototype.get</code></a>, but only works with an integer argument.</p>
      </div>
      
      <div>
        <h4 id="Vector%25compute"><code>Vector#compute(i)</code></h4>
        <p>Compute the entry at index <code>i</code> of the vector. This method is used internally
by <a href="#Vector%25get"><code>Vector.prototype.get</code></a> and <a href="#Vector%25_get"><code>Vector.prototype._get</code></a> to obtain the correct
value in cases where the vector values are stored <em>lazily</em>. Users should not
call it directly. Use <a href="#Vector%25get"><code>Vector.prototype.get</code></a> or <a href="#Vector%25_get"><code>Vector.prototype._get</code></a> instead.</p>
      </div>
      
      <div>
        <h4 id="Vector%25set"><code>Vector#set(ind, vals)</code></h4>
        <p>Set the entries of the vector that are specified by the parameter <code>i</code> to the value(s)
specified by the parameter <code>vals</code>. <em>Can only be used on a vector that is set to
be mutable</em>. The parameters can take two forms:</p>
<ol>
<li>If <code>i</code> is a single numeric index, and <code>vals</code> is the value that should be placed
at that index.</li>
<li>If the parameter <code>i</code> is omitted, i.e. <code>vals</code> is the first argument, then it needs to
be an array or vector of equal length to <code>this</code>, or a single number, or a function <code>f(i)</code>,
and it will be used to set all the vector's values.</li>
</ol>
<p>In order to set more than one of a vector's values at the same time, create a
<a href="#Vector%25view"><code>Vector.prototype.view</code></a> and use set on that.</p>
<p>You may use <a href="#Vector%25_set"><code>Vector.prototype._set</code></a> if efficiency is an issue and you are certain that
you are in the single-index case.</p>
      </div>
      
      <div>
        <h4 id="Vector%25_set"><code>Vector#_set(i, val)</code></h4>
        <p>Set the entry at index <code>i</code> of the vector to <code>val</code>. Can only be used on a vector
that is set to be mutable.</p>
      </div>
      
      <div>
        <h4 id="Vector%25change"><code>Vector#change(i, val)</code></h4>
        <p>Method meant to be used internally for setting the value at index <code>i</code> of the
vector to <code>val</code>. Bypasses the checks made by <a href="#Vector%25_set"><code>Vector.prototype._set</code></a>, including
whether the vector has been set to be mutable. <em>Avoid using this method unless
you are really certain of what you are doing!</em></p>
      </div>
      
      <div>
        <h4 id="Vector%25mutable"><code>Vector#mutable(newSetting)</code></h4>
        <p>Called with no arguments (or with undefined/null argument), return the mutable
state of the vector.</p>
<p>Called with a boolean argument <code>newSetting</code>, set the mutable state to that value
and return the vector.</p>
      </div>
      
      <div>
        <h4 id="Vector%25force"><code>Vector#force()</code></h4>
        <p>Force a vector to be evaluated. This resolves any deferred calculations
needed for the computation of the vector's elements.</p>
<p>Many vector methods, notably <a href="#Vector%25map"><code>Vector.prototype.map</code></a>, delay the required computations
until the point where they need to be computed. <a href="#Vector%25force"><code>Vector.prototype.force</code></a> is one
way to do so.</p>
      </div>
      
      <div>
        <h4 id="Vector%25view"><code>Vector#view(arr, len)</code></h4>
        <p>Return a view vector on the <code>arr</code> indices. View vectors reflect the values on their
target, but allow one to access those locations via a different indexing.
Changing the values of a view vector actually changes the values of their target.</p>
<p>The indices to view may also be specified via af function <code>f(i)</code> as the first argument.
In that case, a second argument is needed with the desired length for the resulting vector.</p>
<pre class="prettyprint source"><code>var v1 = new Vector([3, 5, 1, 2]);
var view = v1.view([2, 3]);
view.get(1) === 5;
view.get(2) === 1;
var view2 = v1.view(function(i) { return 5 - i; }, 3); // [2, 1, 5]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25fill"><code>Vector#fill(val, start, end)</code></h4>
        <p>Fill in the segment of the vector's values from <code>start</code> to <code>end</code> with <code>val</code>.
If <code>start</code> is an array or vector, use its values as the indices to fill.</p>
      </div>
      
      <div>
        <h4 id="Vector%25each"><code>Vector#each(f, skipZeros)</code></h4>
        <p>Execute the function <code>f</code> for each entry of the vector,
starting with the entry with index 1. <code>f</code> will be called as <code>f(value, index)</code>.
If <code>skipZeros</code> is <code>true</code>, then the system <em>may</em> skip the execution
of <code>f</code> for zero entries.</p>
<pre class="prettyprint source"><code>// Prints: 3 1, 5 2, 1 3, 2 4
v.each(console.log);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25forEach"><code>Vector#forEach(f, skipZeros)</code></h4>
        <p>Alias for <a href="#Vector%25each"><code>Vector.prototype.each</code></a>.</p>
      </div>
      
      <div>
        <h4 id="Vector%25eachPair"><code>Vector#eachPair(v2, f, skipZeros)</code></h4>
        <p>Execute the function <code>f</code> for each pair of corresponding entries from the
vector and <code>v2</code>, starting with the entries with index 1.
<code>f</code> will be called as <code>f(value1, value2, index)</code>, where <code>value1</code>, <code>value2</code>
are the entries of the vectors <code>this</code>, <code>v2</code> at index <code>i</code>.
If <code>skipZeros</code> is <code>true</code>, then the system <em>may</em> skip the execution of <code>f</code> when
one of the values is 0.</p>
<pre class="prettyprint source"><code>// Prints 3 3 1, 5 5 2, 1 1 3, 2 2 4
v1.eachPair(v1, console.log);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25reduce"><code>Vector#reduce(f, initial, skipZeros)</code></h4>
        <p>Similar to <code>Array.prototype.reduce</code>. Given a function <code>f(acc, val, i)</code> and an
<code>initial</code> value, it successively calls the function on the vector's entries,
storing each result in the variable <code>acc</code>, then feeding that value back.
If <code>skipZeros</code> is <code>true</code>, this operation <em>may</em> skip any zero entries.
<code>initial</code> and <code>acc</code> do not have to be numbers, but they do need to have the
same type, and <code>f</code> should return that same type.</p>
<pre class="prettyprint source"><code>function add(acc, val) { return acc + val; };
// Equivalent to ((((4 + 3) + 5) + 1) + 2)
v1.reduce(add, 4);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25reducePair"><code>Vector#reducePair(v2, f, initial, skipZeros)</code></h4>
        <p>Similar to <a href="#Vector%25reduce"><code>Vector.prototype.reduce</code></a> but acts on a pair of vectors <code>this</code>, <code>v2</code>.
The signature of the function <code>f</code> would be <code>f(acc, val1, val2, i)</code> where <code>acc</code>
is the accumulated value, <code>i</code> is the index, and <code>val1</code>, <code>val2</code> are the <code>i</code>-indexed
values from <code>this</code>, <code>v2</code>. If <code>skipZeros</code> is <code>true</code>, the implementation <em>may</em> avoid
calling <code>f</code> for an index <code>i</code> if one of the values there is 0.</p>
<p>The vectors <code>this</code>, <code>v2</code> need to have the same length.</p>
<pre class="prettyprint source"><code>function f(acc, val1, val2) = { return acc + val1 * val2; };
// Computes the dot product of v1, v2.
v1.reducePair(v2, f, 0)</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25foldl"><code>Vector#foldl</code></h4>
        <p>Alias for <a href="#Vector%25reduce"><code>Vector.prototype.reduce</code></a>.</p>
      </div>
      
      <div>
        <h4 id="Vector%25map"><code>Vector#map(f, skipZeros)</code></h4>
        <p>Create a new vector by applying the function <code>f</code> to all elements of <code>this</code>.
The function <code>f</code> has the signature <code>f(val, i)</code>.
If <code>skipZeros</code> is <code>true</code>, the operation may assume that <code>f(0, i)=0</code> and
may choose to skip those computations.</p>
<p><a href="#Vector%25map"><code>Vector#map</code></a> only returns a &quot;promise&quot; to compute the resulting vector.
The implementation may choose to not actually compute values <code>f</code> until
they are actually needed. Users should not rely on side-effects of <code>f</code>.</p>
<pre class="prettyprint source"><code>// Results in [4, 7, 4, 6];
v1.map(function(val, i) { return val + i; });</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25mapPair"><code>Vector#mapPair(v2, f, skipZeros)</code></h4>
        <p>Like <a href="#Vector%25map"><code>Vector.prototype.map</code></a>, but the function <code>f</code> acts on two vectors, with
signature <code>f(val1, val2, i)</code>. If <code>skipZeros</code> is <code>true</code>, the implementation may
assume that <code>f</code> will return 0 as long as one of the values is 0.</p>
      </div>
      
      <div>
        <h4 id="Vector%25norm"><code>Vector#norm(p)</code></h4>
        <p>Compute the p-norm of the vector. <code>p</code> should be a positive
number or <code>Infinity</code>. Defaults to the 2-norm.</p>
<pre class="prettyprint source"><code>v.norm(1)        // 1-norm (sum of absolute values)
v.norm()           // 2 norm (usual formula)
v.norm(Infinity) // Infinity (max) norm</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25dot"><code>Vector#dot(v)</code></h4>
        <p>Compute the dot product of <code>this</code> with <code>v</code>.</p>
<pre class="prettyprint source"><code>// Returns 3 * 3 + 5 * 5 + 1 * 1 + 2 * 2
v1.dot(v1);</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25toArray"><code>Vector#toArray()</code></h4>
        <p>Return a Javascript array of the vector's values. Returns a new
Array object every time.</p>
      </div>
      
      <div>
        <h4 id="Vector%25clone"><code>Vector#clone()</code></h4>
        <p>Return a clone of the vector.</p>
      </div>
      
      <div>
        <h4 id="Vector%25equals"><code>Vector#equals(v2, tolerance)</code></h4>
        <p>Test if <code>this</code> pointwise equals <code>v2</code>, within a given pointwise tolerance.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pAdd"><code>Vector#pAdd(v)</code></h4>
        <p>Pointwise add two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pSub"><code>Vector#pSub(v)</code></h4>
        <p>Pointwise subtract two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25sMult"><code>Vector#sMult(a)</code></h4>
        <p>Multiply the vector <code>v</code> by the constant <code>a</code>.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pMult"><code>Vector#pMult(v)</code></h4>
        <p>Pointwise multiply two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pDiv"><code>Vector#pDiv(v)</code></h4>
        <p>Pointwise divide two vectors.</p>
      </div>
      
      <div>
        <h4 id="Vector%25pPow"><code>Vector#pPow(n)</code></h4>
        <p>Raise each entry in <code>v</code> to the <code>n</code>-th power. Return the resulting vector.</p>
      </div>
      
      <div>
        <h4 id="Vector%25diff"><code>Vector#diff()</code></h4>
        <p>Compute consecutive differences of the values in the vector.</p>
<pre class="prettyprint source"><code>// Both produce: [2, -4, 1]
Vector.diff(v1);
v1.diff();
v1.diff().length === v1.length - 1 // true</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumulative"><code>Vector#cumulative(f, initial)</code></h4>
        <p>Create a new vector by accumulating one by one the results
<code>f(acc, val, i)</code> as <code>val</code> ranges over the values of the vector,
starting with the value <code>initial</code>. This is effectively a version of
<code>Vector.reduce</code> where each intermediate step is stored.</p>
<pre class="prettyprint source"><code>function f(acc, val) { return acc + val * val; }
v1.cumulative(f, 2);  // Produces [11, 36, 37, 41]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumSum"><code>Vector#cumSum()</code></h4>
        <p>Create a new vector from the partial sums in the vector.</p>
<pre class="prettyprint source"><code>// Both produce [3, 8, 9, 11]
Vector.prototype.cumSum(v1);
v1.cumSum();</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumProd"><code>Vector#cumProd()</code></h4>
        <p>Create a new vector from the partial products in the vector.</p>
<pre class="prettyprint source"><code>v1.cumProd(); // Produces [3, 15, 15, 30]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumMin"><code>Vector#cumMin()</code></h4>
        <p>Create a new vector from the partial minimums in the vector.</p>
<pre class="prettyprint source"><code>v1.cumMin(); // Produces [3, 5, 1, 1]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25cumMax"><code>Vector#cumMax()</code></h4>
        <p>Create a new vector from the partial maximums in the vector.</p>
<pre class="prettyprint source"><code>v1.cumMax(); // Produces [3, 5, 5, 5]</code></pre>
      </div>
      
      <div>
        <h4 id="Vector%25isSparse"><code>Vector#isSparse()</code></h4>
        <p>Return whether the vector is stored as a sparse vector.</p>
      </div>
      
      <div>
        <h4 id="Vector%25sameLength"><code>Vector#sameLength(other)</code></h4>
        <p>Return whether the vector has the same length as the vector <code>other</code>.</p>
      </div>
      
      <div>
        
        
      </div>
      
    </div>
  </body>
</html>